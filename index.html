<h2>Maths_Addition</h2>

<p>
<img src="Data/Textures/Icons/Maths_Addition.png" width=64 height=64 border=1>
</p>

<p>
Mathematical addition
</p>
<em>Inputs</em>
<ul>
<li>
X: First number to add
</li>
<li>
Y: Second number to add
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Sum: Sum of the numbers
</li>
</ul>
<h2>Maths_Subtraction</h2>

<p>
<img src="Data/Textures/Icons/Maths_Subtraction.png" width=64 height=64 border=1>
</p>

<p>
Mathematical subtraction
</p>
<em>Inputs</em>
<ul>
<li>
X: Number to subtract from
</li>
<li>
Y: Number to subtract
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Result: Result of the subtraction
</li>
</ul>
<h2>Maths_Multiplication</h2>

<p>
<img src="Data/Textures/Icons/Maths_Multiplication.png" width=64 height=64 border=1>
</p>

<p>
Mathematical multiplication
</p>
<em>Inputs</em>
<ul>
<li>
X: First number to multiply
</li>
<li>
Y: Second number to multiply
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Product: Product of the numbers
</li>
</ul>
<h2>Maths_Division</h2>

<p>
<img src="Data/Textures/Icons/Maths_Division.png" width=64 height=64 border=1>
</p>

<p>
Mathematical division
</p>
<em>Inputs</em>
<ul>
<li>
X: Number to divide
</li>
<li>
Y: Number to divide by
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Result: Result of the division
</li>
</ul>
<h2>Maths_GreaterThan</h2>

<p>
<img src="Data/Textures/Icons/Maths_GreaterThan.png" width=64 height=64 border=1>
</p>

<p>
Tests if input B is greater than input A
</p>
<em>Inputs</em>
<ul>
<li>
firstNumber: First number
</li>
<li>
secondNumber: Second number
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Greater than (>): True if A > B
</li>
<li>
Greater than or equal to (>=): True if A >= B
</li>
</ul>
<h2>Maths_LessThan</h2>

<p>
<img src="Data/Textures/Icons/Maths_LessThan.png" width=64 height=64 border=1>
</p>

<p>
Tests if input B is less than input A
</p>
<em>Inputs</em>
<ul>
<li>
firstNumber: First number
</li>
<li>
secondNumber: Second number
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Less than (<): True if A < B
</li>
<li>
Less than or equal to (<=): True if A <= B
</li>
</ul>
<h2>Maths_RandomValue</h2>

<p>
<img src="Data/Textures/Icons/Maths_RandomValue.png" width=64 height=64 border=1>
</p>

<p>
Generates a random float between min and max
</p>
<em>Inputs</em>
<ul>
<li>
Min: Start of range (default = 0)
</li>
<li>
Max: end of range (default = 1)
</li>
<li>
Seed: Seed for random number generator (int)
</li>
<li>
Number: Number of random numbers to generate (int)
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
RnadomValue: Random float between min and max
</li>
</ul>
<h2>Maths_DotProduct</h2>

<p>
<img src="Data/Textures/Icons/Maths_DotProduct.png" width=64 height=64 border=1>
</p>

<p>
Computes the dot product of two vectors
</p>
<em>Inputs</em>
<ul>
<li>
firstVector: First vector
</li>
<li>
secondVector: Second vector
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Dot Product: Float representing X dot Y
</li>
</ul>
<h2>Maths_CrossProduct</h2>

<p>
<img src="Data/Textures/Icons/Maths_CrossProduct.png" width=64 height=64 border=1>
</p>

<p>
Computes the cross product of two vectors
</p>
<em>Inputs</em>
<ul>
<li>
firstVector: First vector
</li>
<li>
secondVector: Second vector
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Cross Product: Float representing X cross Y
</li>
</ul>
<h2>Maths_VectorLength</h2>

<p>
<img src="Data/Textures/Icons/Maths_VectorLength.png" width=64 height=64 border=1>
</p>

<p>
Computes the length of a vector
</p>
<em>Inputs</em>
<ul>
<li>
Vector: Vector
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Length: Float representing length of X
</li>
</ul>
<h2>Maths_UnitizeVector</h2>

<p>
<img src="Data/Textures/Icons/Maths_UnitizeVector.png" width=64 height=64 border=1>
</p>

<p>
Computes a unit vector from a vector
</p>
<em>Inputs</em>
<ul>
<li>
Vector: Vector
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
UnitVector: Unit Vector in direction of X
</li>
</ul>
<h2>Maths_Lerp</h2>

<p>
<img src="Data/Textures/Icons/Maths_Lerp.png" width=64 height=64 border=1>
</p>

<p>
Linear interpolation between two values
</p>
<em>Inputs</em>
<ul>
<li>
From: Value to lerp from
</li>
<li>
To: Value to lerp to
</li>
<li>
T: Parameter t
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Lerped Value: Value at param t
</li>
</ul>
<h2>Maths_RectangularGrid</h2>

<p>
<img src="Data/Textures/Icons/Maths_RectangularGrid.png" width=64 height=64 border=1>
</p>

<p>
Generates a planar rectangular grid from transform, number of cells and cell size
</p>
<em>Inputs</em>
<ul>
<li>
transform: Transform: sets plane for rectangular grid
</li>
<li>
numberX: Number of cells in X direction
</li>
<li>
numberZ: Number of cells in Z direction
</li>
<li>
sizeX: Size of cells in X direction
</li>
<li>
sizeZ: size of cells in Z direction
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Rectangular Grid Vertices: Vertices
</li>
<li>
Rectangular Grid Polylines: Cell Polylines
</li>
</ul>
<h2>Maths_RectangularArray</h2>

<p>
<img src="Data/Textures/Icons/Maths_RectangularArray.png" width=64 height=64 border=1>
</p>

<p>
Generates a 3D rectangular array of cells from transform, number of cells and cell size
</p>
<em>Inputs</em>
<ul>
<li>
transform: Transform for coordinate system
</li>
<li>
numberX: Number of cells in X direction
</li>
<li>
numberY: Number of cells in Y direction
</li>
<li>
numberZ: Number of cells in Z direction
</li>
<li>
sizeX: Size of cells in X direction
</li>
<li>
sizeY: size of cells in Y direction
</li>
<li>
sizeZ: size of cells in Z direction
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Rectangular Grid Vertices: Vertices
</li>
</ul>
<h2>Maths_HexGrid</h2>

<p>
<img src="Data/Textures/Icons/Maths_HexGrid.png" width=64 height=64 border=1>
</p>

<p>
Generates a planar hexagonal grid
</p>
<em>Inputs</em>
<ul>
<li>
transform: Transform: sets plane for hex grid
</li>
<li>
numberX: Number of cells in X direction
</li>
<li>
numberY: Number of cells in Y direction
</li>
<li>
numberZ: Number of cells in Z direction
</li>
<li>
size: Size of cells
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Hexagonal Grid Vertices: Vertices
</li>
<li>
Hexagonal Grid Polylines: Cell Polylines
</li>
</ul>
<h2>Maths_RhodoLattice</h2>

<p>
<img src="Data/Textures/Icons/Maths_RhodoLattice.png" width=64 height=64 border=1>
</p>

<p>
Generates 3D lattice from rhombic dodecahedral tiling
</p>
<em>Inputs</em>
<ul>
<li>
transform: Transform for coordinate system
</li>
<li>
numberX: Approx. width in rhodo diameters along x-axis of box
</li>
<li>
numberY: Approx. width in rhodo diameters along y-axis of box
</li>
<li>
numberZ: Approx. width in rhodo diameters along z-axis of box
</li>
<li>
Diameter: Diameter of one rhombic dodecahedron
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Rectangular Grid Vertices: Vertices
</li>
<li>
Rhodo Lattice Polylines: ...
</li>
</ul>
<h2>Geometry_Rotation</h2>

<p>
<img src="Data/Textures/Icons/Geometry_Rotation.png" width=64 height=64 border=1>
</p>

<p>
Construct a rotation quaternion from axis and angle
</p>
<em>Inputs</em>
<ul>
<li>
Axis: Axis (unit vector)
</li>
<li>
Angle: Angle of rotation (in radians)
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Rotation Quaternion: Rotation quaternion out
</li>
<li>
Rotation Transform: Rotation transformation out
</li>
</ul>
<h2>Geometry_LookAt</h2>

<p>
<img src="Data/Textures/Icons/Geometry_LookAt.png" width=64 height=64 border=1>
</p>

<p>
Construct a rotation quaternion from axis and angle
</p>
<em>Inputs</em>
<ul>
<li>
TargetPoint: Target Point
</li>
<li>
Up: Optional Up direction.
</li>
<li>
Transform: Option transform to modify
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Rotation Transform: Rotation transformation out
</li>
</ul>
<h2>Geometry_AffineTransformation</h2>

<p>
<img src="Data/Textures/Icons/Geometry_AffineTransformation.png" width=64 height=64 border=1>
</p>

<p>
Apply spatial transformation to geometric object
</p>
<em>Inputs</em>
<ul>
<li>
Geometry: Mesh to transform
</li>
<li>
Transformation: Transformation to apply to geometry
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NewGeometry: Transformed Geometry
</li>
</ul>
<h2>Sets_Series</h2>

<p>
<img src="Data/Textures/Icons/Sets_Series.png" width=64 height=64 border=1>
</p>

<p>
Create a series of numbers
</p>
<em>Inputs</em>
<ul>
<li>
Start: First number in the series
</li>
<li>
Step: Step size for each successive number
</li>
<li>
Count: Number of values in the series
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Series: Series of numbers
</li>
</ul>
<h2>Sets_LogisticGrowthSeries</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
Create a series of numbers following logistic growth curve
</p>
<em>Inputs</em>
<ul>
<li>
MaxVal: Maximum Value in the series
</li>
<li>
Steepness: rate of increase
</li>
<li>
Count: Number of values in the series
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Series: Series of numbers
</li>
</ul>
<h2>Sets_ListItem</h2>

<p>
<img src="Data/Textures/Icons/Sets_ListItem.png" width=64 height=64 border=1>
</p>

<p>
Select items by index
</p>
<em>Inputs</em>
<ul>
<li>
List: List of items
</li>
<li>
Indices: Indices of desired list items
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
List items: Selected list items
</li>
</ul>
<h2>Sets_IfThen</h2>

<p>
<img src="Data/Textures/Icons/Sets_IfThen.png" width=64 height=64 border=1>
</p>

<p>
Separates list items according to pattern
</p>
<em>Inputs</em>
<ul>
<li>
List: List of items
</li>
<li>
Pattern: Pattern of separation
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
List A: 'true' list items
</li>
<li>
List B: 'false list items
</li>
</ul>
<h2>Sets_Merge</h2>

<p>
<img src="Data/Textures/Icons/Sets_Merge.png" width=64 height=64 border=1>
</p>

<p>
Merges two lists according to pattern
</p>
<em>Inputs</em>
<ul>
<li>
List_A: First List
</li>
<li>
List_B: Second List
</li>
<li>
Pattern: Pattern of separation
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
MergedList: New compsed list
</li>
</ul>
<h2>Sets_ListConstruct</h2>

<p>
<img src="Data/Textures/Icons/Sets_ListConstruct.png" width=64 height=64 border=1>
</p>

<p>
Construct a list from items
</p>
<em>Inputs</em>
<ul>
<li>
Item1: First item
</li>
<li>
Item2: Second item
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
List: List of items
</li>
</ul>
<h2>Sets_ShiftList</h2>

<p>
<img src="Data/Textures/Icons/Sets_ShiftList.png" width=64 height=64 border=1>
</p>

<p>
Select items by index
</p>
<em>Inputs</em>
<ul>
<li>
List: List of items
</li>
<li>
Shift Length: Number of indices to shift
</li>
<li>
Wrap: Wrap the indices to branch count
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Shifted List: Selected list items
</li>
</ul>
<h2>Sets_LoopBegin</h2>

<p>
<img src="Data/Textures/Icons/Sets_LoopBegin.png" width=64 height=64 border=1>
</p>

<p>
Entry point for a For Loop
</p>
<em>Inputs</em>
<ul>
<li>
Name: Optional label for this loop.
</li>
<li>
Steps: Number of steps to compute. -1 for indefinite loop
</li>
<li>
Data: Initial Data
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Index: Current index
</li>
<li>
Data: Optional temporary data
</li>
</ul>
<h2>Sets_LoopEnd</h2>

<p>
<img src="Data/Textures/Icons/Sets_LoopEnd.png" width=64 height=64 border=1>
</p>

<p>
Ends a loop or transmits data back to start.
</p>
<em>Inputs</em>
<ul>
<li>
LoopStart: Loop start component to operate on. Connect to any Loop Start output.
</li>
<li>
Stop: Optional bool to stop loop
</li>
<li>
Data: Generic data to transmit back to start
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Last Data: Last computed data
</li>
</ul>
<h2>Sets_DataRecorder</h2>

<p>
<img src="Data/Textures/Icons/Sets_DataRecorder.png" width=64 height=64 border=1>
</p>

<p>
Records generic data and outputs to list.
</p>
<em>Inputs</em>
<ul>
<li>
DataItem: Data to record
</li>
<li>
RecordLimit: Number of items to record
</li>
<li>
Reset: Reset the recording
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Data: Optional temporary data
</li>
</ul>
<h2>Sets_AddKeyValue</h2>

<p>
<img src="Data/Textures/Icons/Sets_AddKeyValue.png" width=64 height=64 border=1>
</p>

<p>
Adds a key value pair to a variant map
</p>
<em>Inputs</em>
<ul>
<li>
Map: Variant map to operate on. Can be empty.
</li>
<li>
Key: Key of value to add
</li>
<li>
Value: Value add. This input is list access.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Map out: Variant map out.
</li>
</ul>
<h2>Sets_GetValueByKey</h2>

<p>
<img src="Data/Textures/Icons/Sets_GetValueByKey.png" width=64 height=64 border=1>
</p>

<p>
Gets a value by key name.
</p>
<em>Inputs</em>
<ul>
<li>
Map: Variant map to operate on. Can be empty.
</li>
<li>
Key: Key of value to add
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Value out: Value out
</li>
</ul>
<h2>Sets_ExportViewData</h2>

<p>
<img src="Data/Textures/Icons/Sets_ExportViewData.png" width=64 height=64 border=1>
</p>

<p>
Exports data from a view to be used in another view.
</p>
<em>Inputs</em>
<ul>
<li>
Data: Data tree to export
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ExportedData: Exported Data
</li>
</ul>
<h2>Sets_ImportViewData</h2>

<p>
<img src="Data/Textures/Icons/Sets_ImportViewData.png" width=64 height=64 border=1>
</p>

<p>
Imports data from a view to be used in this view.
</p>
<em>Inputs</em>
<ul>
<li>
DataIn: Data in
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ImportedData: Exported Data
</li>
</ul>
<h2>Maths_MassAverage</h2>

<p>
<img src="Data/Textures/Icons/Maths_MassAverage.png" width=64 height=64 border=1>
</p>

<p>
Average of list of numbers
</p>
<em>Inputs</em>
<ul>
<li>
List: List of floating point values
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Average: Average of values
</li>
</ul>
<h2>Maths_MassAddition</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
Sums a list of numbers
</p>
<em>Inputs</em>
<ul>
<li>
List: List of floating point values
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Sum: Sum of values
</li>
</ul>
<h2>Input_Slider</h2>

<p>
<img src="Data/Textures/Icons/Input_Slider.png" width=64 height=64 border=1>
</p>

<p>
An interactive numerical slider.
</p>
<em>Inputs</em>
<ul>
<li>
I: 
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Value: 
</li>
</ul>
<h2>Input_Panel</h2>

<p>
<img src="Data/Textures/Icons/Input_Panel.png" width=64 height=64 border=1>
</p>

<p>

</p>
<em>Inputs</em>
<ul>
<li>
: 
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
: 
</li>
</ul>
<h2>Input_Float</h2>

<p>
<img src="Data/Textures/Icons/Input_Float.png" width=64 height=64 border=1>
</p>

<p>
Creates or casts a float
</p>
<em>Inputs</em>
<ul>
<li>
Number: Non-float number
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Float: Float
</li>
</ul>
<h2>Input_Int</h2>

<p>
<img src="Data/Textures/Icons/Input_Integer.png" width=64 height=64 border=1>
</p>

<p>
Creates or casts an integer
</p>
<em>Inputs</em>
<ul>
<li>
Number: Non-integer number
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Integer: Integer
</li>
</ul>
<h2>Input_Label</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
Label for annotating graphs
</p>
<em>Inputs</em>
<ul>
<li>
Name: Name of this label
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ContainerElement: Container Element
</li>
</ul>
<h2>Input_Toggle</h2>

<p>
<img src="Data/Textures/Icons/Input_Toggle.png" width=64 height=64 border=1>
</p>

<p>
Boolean Toggle input
</p>
<em>Inputs</em>
<ul>
<li>
: 
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
: 
</li>
</ul>
<h2>Input_ScreenToggle</h2>

<p>
<img src="Data/Textures/Icons/Input_ScreenToggle.png" width=64 height=64 border=1>
</p>

<p>
Adds a boolean toggle to the user interface
</p>
<em>Inputs</em>
<ul>
<li>
P: Position of the button in screen coordinates.
</li>
<li>
Label: Label of the button
</li>
<li>
Toggle: Toggle mode
</li>
<li>
Priority: Priority Index
</li>
<li>
Parent: Optional parent
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Button Pointer: Pointer to the UI Element
</li>
</ul>
<h2>Input_ScreenContainer</h2>

<p>
<img src="Data/Textures/Icons/Input_ScreenContainer.png" width=64 height=64 border=1>
</p>

<p>
A container for UI objects.
</p>
<em>Inputs</em>
<ul>
<li>
Name: Name of this container
</li>
<li>
Position: Optional position. If left blank, the element is automatically positioned.
</li>
<li>
Size: Optional size. If left blank, the element is automatically size.
</li>
<li>
Options: Container options
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ContainerElement: Container Element
</li>
</ul>
<h2>Input_CustomElement</h2>

<p>
<img src="Data/Textures/Icons/Input_CustomElement.png" width=64 height=64 border=1>
</p>

<p>
Adds some text to the screen UI
</p>
<em>Inputs</em>
<ul>
<li>
CustomType: Custom type name to create. Name must be contained the style file
</li>
<li>
Style File: Optional file to look up. If blank, the default style file will be used.
</li>
<li>
Position: Optional position. If left blank, the element is automatically positioned.
</li>
<li>
Size: Size of root element
</li>
<li>
Priority: Priority
</li>
<li>
Parent: Optional Parent element
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
CustomElement: Custom Element
</li>
<li>
Children: Children elements.
</li>
</ul>
<h2>Input_ButtonListener</h2>

<p>
<img src="Data/Textures/Icons/Input_ToggleListener.png" width=64 height=64 border=1>
</p>

<p>
Listens to button in scene
</p>
<em>Inputs</em>
<ul>
<li>
Button Pointers: Pointers to screen buttons
</li>
<li>
Mute: Mute this listener
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Values: Values Out
</li>
</ul>
<h2>Input_LineEditListener</h2>

<p>
<img src="Data/Textures/Icons/Input_LineEditListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for line edit input
</p>
<em>Inputs</em>
<ul>
<li>
LineEdit Pointers: Pointers to screen line edit
</li>
<li>
Mute: Mute this listener
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Values: Values Out
</li>
</ul>
<h2>Input_KeyboardListener</h2>

<p>
<img src="Data/Textures/Icons/Input_KeyboardListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for Key strokes
</p>
<em>Inputs</em>
<ul>
<li>
On: Listen for mouse clicks
</li>
<li>
Key Filter: Keys to listen to. If blank, return all.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Key Press: Returns once on the frame that the key has pressed.
</li>
<li>
Key Down: Returns on every frame that the key is held down.
</li>
<li>
Key Up: Returns once on the frame that the key is released.
</li>
</ul>
<h2>Input_MouseDownListener</h2>

<p>
<img src="Data/Textures/Icons/Input_MouseDownListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for mouse down in scene
</p>
<em>Inputs</em>
<ul>
<li>
On: Listen for mouse clicks
</li>
<li>
Mouse button: Mouse Button
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mouse Position: Mouse Position
</li>
<li>
Mouse Delta: Mouse Delta
</li>
</ul>
<h2>Input_GamepadListener</h2>

<p>
<img src="Data/Textures/Icons/Input_GamepadListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for gamepad input
</p>
<em>Inputs</em>
<ul>
<li>
On: Listen for mouse clicks
</li>
<li>
Gamepad index: Gamepad Index
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Button ID: Button ID
</li>
<li>
Button Value: Button Value
</li>
<li>
Axis ID: Axis ID
</li>
<li>
Axis Value: Axis Value
</li>
</ul>
<h2>Input_ScreenLineEdit</h2>

<p>
<img src="Data/Textures/Icons/Input_ScreenLineEdit.png" width=64 height=64 border=1>
</p>

<p>
Adds a line edit to the user interface
</p>
<em>Inputs</em>
<ul>
<li>
Screen Coords: Point Coordinate in Screen Space
</li>
<li>
Label: Label
</li>
<li>
Priority: Optional priority index
</li>
<li>
Parent: Optional parent
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Line Edit out: Ptr to line edit
</li>
</ul>
<h2>Input_ScreenText</h2>

<p>
<img src="Data/Textures/Icons/Input_ScreenText.png" width=64 height=64 border=1>
</p>

<p>
Adds some text to the screen UI
</p>
<em>Inputs</em>
<ul>
<li>
Position: Optional position. If left blank, the element is automatically positioned.
</li>
<li>
Text: Text to display
</li>
<li>
Font: Path to Font to use
</li>
<li>
Size: Font Size
</li>
<li>
Priority: Priority
</li>
<li>
Parent: Optional Parent element
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
TextElement: Text Element
</li>
</ul>
<h2>Input_StringReplace</h2>

<p>
<img src="Data/Textures/Icons/Input_StringReplace.png" width=64 height=64 border=1>
</p>

<p>
Appends or Creates a string with Formatting.
</p>
<em>Inputs</em>
<ul>
<li>
String: String to work on
</li>
<li>
ReplaceThis: String to replace
</li>
<li>
ReplaceWith: Replacement string
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
String: Resulting string
</li>
</ul>
<h2>Input_StringAppend</h2>

<p>
<img src="Data/Textures/Icons/Input_StringAppend.png" width=64 height=64 border=1>
</p>

<p>
Appends a string.
</p>
<em>Inputs</em>
<ul>
<li>
InputString: Input String
</li>
<li>
AppendString: String to append
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
String: Resulting string
</li>
</ul>
<h2>Input_ScanDir</h2>

<p>
<img src="Data/Textures/Icons/Input_ScanDir.png" width=64 height=64 border=1>
</p>

<p>
Scans a directory for files.
</p>
<em>Inputs</em>
<ul>
<li>
Path: Directory path
</li>
<li>
Filter: Optional filter
</li>
<li>
Recursive: Search directory recursively
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Results: Scanned files
</li>
<li>
FullPaths: Full paths to scanned files
</li>
</ul>
<h2>Input_Trigger</h2>

<p>
<img src="Data/Textures/Icons/Input_Trigger.png" width=64 height=64 border=1>
</p>

<p>
Transmit IoDataTree at first input upon trigger at second input
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree input to transmit on trigger
</li>
<li>
Trigger: Trigger -- listen for change in trigger input
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IoDataTree: IoDataTree transmitted on trigger
</li>
</ul>
<h2>Input_ObjectMove</h2>

<p>
<img src="Data/Textures/Icons/Input_ObjectMove.png" width=64 height=64 border=1>
</p>

<p>
Moves an object based on user interaction
</p>
<em>Inputs</em>
<ul>
<li>
Constraints: Movement constraints. One bit for each of the 6 degrees of freedom
</li>
<li>
Local Coords: Using local Coords for translation
</li>
<li>
Node Filter: Only allow movement on these nodes. If 0, all nodes are allowed to move.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ID: ID of affected node
</li>
<li>
Transform: Transform defining movement
</li>
</ul>
<h2>Input_Vector3</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
Slider for selecting a Vector3
</p>
<em>Inputs</em>
<ul>
<li>
Default: Vector3
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Vector3: Vector output
</li>
</ul>
<h2>Input_ColorSlider</h2>

<p>
<img src="Data/Textures/Icons/Input_ColorWheel.png" width=64 height=64 border=1>
</p>

<p>
Slider for selecting a Color
</p>
<em>Inputs</em>
<ul>
<li>
Color: Color
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Color_out: Color output
</li>
</ul>
<h2>Input_GeometryEdit</h2>

<p>
<img src="Data/Textures/Icons/Input_GeometryEdit.png" width=64 height=64 border=1>
</p>

<p>
Allows the user to manipulate geometry vertices.
</p>
<em>Inputs</em>
<ul>
<li>
Geometry: Geometry to operate on.
</li>
<li>
Constraints: Movement constraints. One bit for each of the 6 degrees of freedom
</li>
<li>
DisplayThickness: Thickness of display curves
</li>
<li>
Color: Color of diplay curves
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Edit Geometry: Reference to Edit Geometry. Connect to Edit Geometry Listener.
</li>
</ul>
<h2>Input_EditGeometryListener</h2>

<p>
<img src="Data/Textures/Icons/Input_EditGeometryListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for updates to editable geometry
</p>
<em>Inputs</em>
<ul>
<li>
NodeID: Id of edit geometry to listen to.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Geometry: Edited geometry
</li>
</ul>
<h2>Interop_SystemCommand</h2>

<p>
<img src="Data/Textures/Icons/Interop_SystemCommand.png" width=64 height=64 border=1>
</p>

<p>
Calls a program from the OS
</p>
<em>Inputs</em>
<ul>
<li>
Executable: The executable to call
</li>
<li>
Arguments: Arguments
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ExitCode: Result of the call
</li>
</ul>
<h2>Interop_AsyncSystemCommand</h2>

<p>
<img src="Data/Textures/Icons/Interop_AsyncSystemCommand.png" width=64 height=64 border=1>
</p>

<p>
Calls several programs from the OS
</p>
<em>Inputs</em>
<ul>
<li>
Executable: The executable to call asynchronously
</li>
<li>
Arguments: Arguments
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ExitCode: Result of the call
</li>
</ul>
<h2>Interop_SendData</h2>

<p>
<img src="Data/Textures/Icons/Interop_SendData.png" width=64 height=64 border=1>
</p>

<p>
Exports data from a view to be used in another view.
</p>
<em>Inputs</em>
<ul>
<li>
Data: Data tree to export
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ExportedData: Exported Data
</li>
<li>
IP: IP Address
</li>
</ul>
<h2>Interop_ReceiveData</h2>

<p>
<img src="Data/Textures/Icons/Interop_ReceiveData.png" width=64 height=64 border=1>
</p>

<p>
Exports data from a view to be used in another view.
</p>
<em>Inputs</em>
<ul>
<li>
Data: Data tree to export
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ExportedData: Exported Data
</li>
</ul>
<h2>Resource_LoadResource</h2>

<p>
<img src="Data/Textures/Icons/Resource_LoadResource.png" width=64 height=64 border=1>
</p>

<p>
Loads a resource from a path
</p>
<em>Inputs</em>
<ul>
<li>
Path: Path to Resource file (e.g. "Models/TeaPot.mdl")
</li>
<li>
Type: Type Name. Must be a registered class type. (e.g. "model")
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ResourcePointer: Void Pointer to Resource
</li>
</ul>
<h2>Resource_CreateMaterial</h2>

<p>
<img src="Data/Textures/Icons/Resource_CreateMaterial.png" width=64 height=64 border=1>
</p>

<p>
Create a material from parameters
</p>
<em>Inputs</em>
<ul>
<li>
Technique: Path to material
</li>
<li>
Parameters: Key-Value pairs of parameters to modify
</li>
<li>
Textures: Key-Value pairs of tex units and resource paths
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Material: Pointer to material
</li>
</ul>
<h2>Graphics_BaseSettings</h2>

<p>
<img src="Data/Textures/Icons/Graphics_BaseSettings.png" width=64 height=64 border=1>
</p>

<p>
Sets a few of the most important render settings.
</p>
<em>Inputs</em>
<ul>
<li>
Skybox: Set the skybox material
</li>
<li>
ZoneTexture: Zone Texture (for reflections)
</li>
<li>
Zone Size: Vector defined size of the render zone
</li>
<li>
AmbientLight: Ambient Light. Alpha channel determines brightness.
</li>
<li>
Fog Color: Color of Fog.
</li>
<li>
Fog extents: Fog extents. Vector 3 where x,y are start and end distances. Z is density.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Zone: Pointer to zone
</li>
<li>
Skybox: Pointer to skybox
</li>
</ul>
<h2>Graphics_Viewport</h2>

<p>
<img src="Data/Textures/Icons/Graphics_Viewport.png" width=64 height=64 border=1>
</p>

<p>
Creates a viewport for viewing geometry
</p>
<em>Inputs</em>
<ul>
<li>
Viewport Index: Index of viewport to create. If exists, viewport will be overwritten.
</li>
<li>
Camera: Camera with which to render viewport.
</li>
<li>
Rect: Screen space rectangle in which to render. If null, full extents are used.
</li>
<li>
RenderPath: Base RenderPath for viewport. If blank, this will default to the main viewport path.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Viewport: Point to resulting viewport
</li>
</ul>
<h2>Graphics_MeshRenderer</h2>

<p>
<img src="Data/Textures/Icons/Scene_MeshRenderer.png" width=64 height=64 border=1>
</p>

<p>
Converts a mesh to a viewable object in the scene.
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh Structure
</li>
<li>
Material: Path to material.
</li>
<li>
SplitVertices: Split the vertices for flat shading
</li>
<li>
Color: MainColor
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NodeID: ID of rendered node
</li>
<li>
StaticModelPointer: Void Pointer to Static Model
</li>
</ul>
<h2>Graphics_MeshEdges</h2>

<p>
<img src="Data/Textures/Icons/Graphics_MeshEdges.png" width=64 height=64 border=1>
</p>

<p>
Renders mesh edges
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to render
</li>
<li>
Width: Width of curve
</li>
<li>
Color: Color
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Node ID: Node ID
</li>
</ul>
<h2>Graphics_CurveToModel</h2>

<p>
<img src="Data/Textures/Icons/Graphics_CurveToModel.png" width=64 height=64 border=1>
</p>

<p>
Converts a curve to a model on disk with a pointer to the model
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline structure
</li>
<li>
File: Optional path to save Model
</li>
<li>
Thickness: Line thickness
</li>
<li>
VertexColors: VertexColors
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ModelPointer: Void Pointer to Model
</li>
</ul>
<h2>Graphics_CurveRenderer</h2>

<p>
<img src="Data/Textures/Icons/Graphics_CurveRenderer.png" width=64 height=64 border=1>
</p>

<p>
Curve Renderer
</p>
<em>Inputs</em>
<ul>
<li>
Curve: Curve to render
</li>
<li>
Width: Width of curve
</li>
<li>
Color: Color
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Node ID: Node ID
</li>
</ul>
<h2>Graphics_RenderTexture</h2>

<p>
<img src="Data/Textures/Icons/Graphics_RenderTexture.png" width=64 height=64 border=1>
</p>

<p>
Creates a texture that is filled by the given camera.
</p>
<em>Inputs</em>
<ul>
<li>
Camera: Camera with which to render viewport.
</li>
<li>
Viewport: Optional viewport to use for render texture
</li>
<li>
RenderPath: Base RenderPath for viewport. If blank, this will default to the main viewport path.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Texture: Render Texture
</li>
<li>
Material: Basic Material with the RenderTexture assigned.
</li>
</ul>
<h2>Graphics_Light</h2>

<p>
<img src="Data/Textures/Icons/Graphics_Light.png" width=64 height=64 border=1>
</p>

<p>
Create a directional Sun light
</p>
<em>Inputs</em>
<ul>
<li>
Transform: Transform
</li>
<li>
LightType: LightType
</li>
<li>
Color: Color
</li>
<li>
Range: Range
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NodeID: Node ID
</li>
<li>
Light: LightPtr
</li>
</ul>
<h2>Physics_ApplyForce</h2>

<p>
<img src="Data/Textures/Icons/Physics_ApplyForce.png" width=64 height=64 border=1>
</p>

<p>
Apply a force (vector with magnitude) to a rigid body
</p>
<em>Inputs</em>
<ul>
<li>
RigidBody: RigidyBody
</li>
<li>
Force: Vector defining the force
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
RigidBody: Rigid Body
</li>
</ul>
<h2>Physics_CollisionShape</h2>

<p>
<img src="Data/Textures/Icons/Physics_CollisionShape.png" width=64 height=64 border=1>
</p>

<p>
Construct a collision shape form a mesh or model
</p>
<em>Inputs</em>
<ul>
<li>
Node ID: Node to construct collision shape on
</li>
<li>
Base Mesh: Mesh to construct collision shape from
</li>
<li>
Shape type: Type of collision shape to create
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
RigidBody: Rigid Body
</li>
</ul>
<h2>Physics_Constraint</h2>

<p>
<img src="Data/Textures/Icons/Physics_Constraint.png" width=64 height=64 border=1>
</p>

<p>
Construct a constraint between a rigidbody and an optional second one.
</p>
<em>Inputs</em>
<ul>
<li>
Body A: First rigidbody.
</li>
<li>
Local Anchor A: Position in local coordinates for start of constraint
</li>
<li>
Body B: Second rigidbody.
</li>
<li>
Local Anchor B: Position in local coordinates for end of constraint
</li>
<li>
Constraint Type: Type of constraint
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Constraint: Constraint
</li>
</ul>
<h2>Scene_Display</h2>

<p>
<img src="Data/Textures/Icons/Scene_Display.png" width=64 height=64 border=1>
</p>

<p>
Displays geometry in the scene
</p>
<em>Inputs</em>
<ul>
<li>
Geometry: Geometry to render
</li>
<li>
Color: Color to Display
</li>
<li>
Mode: Display Mode. 0 - Fill, 1 - Wireframe, 2 - Points.
</li>
<li>
Flat: Flat shaded
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Node: Node ID of display
</li>
<li>
Model: Pointer to model
</li>
</ul>
<h2>Scene_DeconstructModel</h2>

<p>
<img src="Data/Textures/Icons/Scene_DeconstructModel.png" width=64 height=64 border=1>
</p>

<p>
Deconstructs a static model into vertices, faces and normals
</p>
<em>Inputs</em>
<ul>
<li>
Model: Path to Model
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh Out
</li>
</ul>
<h2>Scene_AddNode</h2>

<p>
<img src="Data/Textures/Icons/Scene_AddNode.png" width=64 height=64 border=1>
</p>

<p>
Adds a node with optional name and parent
</p>
<em>Inputs</em>
<ul>
<li>
Transform: Transform of node
</li>
<li>
Name: Optional node name
</li>
<li>
Parent: Optional node parent
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Node ID: ID of node
</li>
</ul>
<h2>Scene_CloneNode</h2>

<p>
<img src="Data/Textures/Icons/Scene_CloneNode.png" width=64 height=64 border=1>
</p>

<p>
Clones a node
</p>
<em>Inputs</em>
<ul>
<li>
NodeID: ID of node to clone
</li>
<li>
Transform: Transform of cloned node
</li>
<li>
ParentID: Optional parent of cloned node
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NodeID: ID of new node
</li>
</ul>
<h2>Scene_AddStaticModel</h2>

<p>
<img src="Data/Textures/Icons/Scene_AddStaticModel.png" width=64 height=64 border=1>
</p>

<p>
Adds a static model
</p>
<em>Inputs</em>
<ul>
<li>
NodeID: ID of node
</li>
<li>
Model: Pointer to Model
</li>
<li>
Material: Pointer to Material
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Static Model: Pointer to static Model
</li>
</ul>
<h2>Scene_AnimatedModel</h2>

<p>
<img src="Data/Textures/Icons/Scene_AnimatedModel.png" width=64 height=64 border=1>
</p>

<p>
Adds a static model
</p>
<em>Inputs</em>
<ul>
<li>
NodeID: ID of node
</li>
<li>
AnimatedModel: Pointer or path to Model
</li>
<li>
Material: Pointer to Material
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Animated Model: Pointer to animated Model
</li>
</ul>
<h2>Scene_PlayAnimation</h2>

<p>
<img src="Data/Textures/Icons/Scene_PlayAnimation.png" width=64 height=64 border=1>
</p>

<p>
Play an animation
</p>
<em>Inputs</em>
<ul>
<li>
NodeID: ID of node
</li>
<li>
AnimationController: Pointer to animation contorller
</li>
<li>
Animation: Path to animation
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Animated Model: Pointer to animated Model
</li>
</ul>
<h2>Scene_ScreenPointToRay</h2>

<p>
<img src="Data/Textures/Icons/Scene_ScreenPointToRay.png" width=64 height=64 border=1>
</p>

<p>
Given a screen point, returns a ray in world coordinates
</p>
<em>Inputs</em>
<ul>
<li>
ScreenPoint: Point in normalized screen coordinates
</li>
<li>
CameraPtr: Optional pointer to a camera. If none provided, a camera will be found.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Start Point: Start point of ray in world coords
</li>
<li>
Direction: Direction of ray in world coords
</li>
</ul>
<h2>Scene_Raycast</h2>

<p>
<img src="Data/Textures/Icons/Scene_Raycast.png" width=64 height=64 border=1>
</p>

<p>
Listens for screen raycasts, returns hit information
</p>
<em>Inputs</em>
<ul>
<li>
StartPoint: Point in world coords
</li>
<li>
Direction: Direction in which to cast ray
</li>
<li>
Max Distance: Max distance to raycast
</li>
<li>
Mask: Mask elements from raycast
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Hit Points: Hit Points of ray
</li>
<li>
Distance: Distance
</li>
<li>
Normal: Normal
</li>
<li>
ModelPtr: Model pointer.
</li>
</ul>
<h2>Scene_ScreenBloom</h2>

<p>
<img src="Data/Textures/ScreenBloom.png" width=64 height=64 border=1>
</p>

<p>
Adds intensity-controlled screen bloom effect
</p>
<em>Inputs</em>
<ul>
<li>
Intensity: Intensity of Bloom
</li>
<li>
Source: Source Mix
</li>
<li>
Bloom Mix: Bloom Mix
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Vertices: Vertices Out
</li>
</ul>
<h2>Physics_PhysicsWorld</h2>

<p>
<img src="Data/Textures/Icons/Physics_PhysicsWorld.png" width=64 height=64 border=1>
</p>

<p>
Initializes physics world
</p>
<em>Inputs</em>
<ul>
<li>
Step: Run physics
</li>
<li>
Gravity: Gravity Vector
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Physics World: Pointer to static physics world
</li>
</ul>
<h2>Physics_RigidBody</h2>

<p>
<img src="Data/Textures/Icons/Physics_RigidBody.png" width=64 height=64 border=1>
</p>

<p>
Adds rigid body behaviour to a node
</p>
<em>Inputs</em>
<ul>
<li>
Node ID: Node ID to add Rigid body to.
</li>
<li>
Physics World: Physics World
</li>
<li>
Mass: Mass. Set to zero if you want a fixed object
</li>
<li>
Shape type: Collision shape type.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Rigid Body: Pointer to Rigid Body
</li>
<li>
Collision Shape: Pointer to Collision Shape
</li>
</ul>
<h2>Scene_Text3D</h2>

<p>
<img src="Data/Textures/Icons/Scene_Text3D.png" width=64 height=64 border=1>
</p>

<p>
Creates a 3D text node at given position and scale
</p>
<em>Inputs</em>
<ul>
<li>
Text: Text to display
</li>
<li>
Positon: Position of text node.
</li>
<li>
Font: Font to display
</li>
<li>
Scale: Scale of text
</li>
<li>
Options: 3D Text options as bitmask. 1 - face camera, 2 - keep vertical, 4 - constant pixel size.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ID: ID of node
</li>
<li>
TextPointer: Pointer to text component
</li>
</ul>
<h2>Scene_ScriptInstance</h2>

<p>
<img src="Data/Textures/Icons/Scene_ScriptInstance.png" width=64 height=64 border=1>
</p>

<p>
Executes a script from file
</p>
<em>Inputs</em>
<ul>
<li>
ScriptFile: Path to script file
</li>
<li>
X: Input variable called X
</li>
<li>
Y: Input variable called Y
</li>
<li>
Z: Input variable called Z
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
A: Output variable called A
</li>
<li>
B: Output variable called B
</li>
<li>
C: Output variable called C
</li>
</ul>
<h2>Scene_MouseClickListener</h2>

<p>
<img src="Data/Textures/Icons/Input_MouseClickListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for mouse clickkinput
</p>
<em>Inputs</em>
<ul>
<li>
On: Listen for mouse clicks (bool)
</li>
<li>
Mouse button: Mouse Button
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mouse Position: Mouse Position
</li>
</ul>
<h2>Scene_SelectGeometry</h2>

<p>
<img src="Data/Textures/Icons/Scene_SelectGeometry.png" width=64 height=64 border=1>
</p>

<p>
Returns selected geometry
</p>
<em>Inputs</em>
<ul>
<li>
On: Activate selection
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
MeshesOut: Meshes out
</li>
<li>
PolylinesOut: Polylines out
</li>
<li>
PointsOut: Points out
</li>
<li>
Mouse Position: Mouse Position
</li>
</ul>
<h2>Scene_ModifyNode</h2>

<p>
<img src="Data/Textures/Icons/Scene_ModifyNode.png" width=64 height=64 border=1>
</p>

<p>
Modifies basic properties of a Node
</p>
<em>Inputs</em>
<ul>
<li>
ID: Node ID
</li>
<li>
Transform: New transfrom
</li>
<li>
Name: Name
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ID: ID of node
</li>
<li>
: 
</li>
</ul>
<h2>Scene_GetNode</h2>

<p>
<img src="Data/Textures/Icons/Scene_GetNode.png" width=64 height=64 border=1>
</p>

<p>
Finds a Node
</p>
<em>Inputs</em>
<ul>
<li>
NodeID: ID of node to inspect.
</li>
<li>
: 
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NodeID: Node ID
</li>
<li>
Name: Name
</li>
<li>
Transform: Transform
</li>
</ul>
<h2>Scene_GetComponent</h2>

<p>
<img src="Data/Textures/Icons/Scene_GetComponent.png" width=64 height=64 border=1>
</p>

<p>
Gets a reference to a component from Node ID
</p>
<em>Inputs</em>
<ul>
<li>
Node ID: Node ID
</li>
<li>
Type: Type of component to return
</li>
<li>
Recursive: Search node recursively
</li>
<li>
: 
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Reference: Reference to component
</li>
</ul>
<h2>Scene_AddComponent</h2>

<p>
<img src="Data/Textures/Icons/Scene_AddComponent.png" width=64 height=64 border=1>
</p>

<p>
Adds a native component to a scene node.
</p>
<em>Inputs</em>
<ul>
<li>
Node ID: Node ID to add component
</li>
<li>
Type: Type of component to add.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Reference: Reference to added component
</li>
</ul>
<h2>Scene_ModifyComponent</h2>

<p>
<img src="Data/Textures/Icons/Scene_ModifyComponent.png" width=64 height=64 border=1>
</p>

<p>
Modifies the properties of a native component.
</p>
<em>Inputs</em>
<ul>
<li>
Component Reference: Pointer reference to native component.
</li>
<li>
Property: Name of Property to modify.
</li>
<li>
Value: Value with which to modify property.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Reference: Reference to modified component
</li>
</ul>
<h2>Scene_SendEvent</h2>

<p>
<img src="Data/Textures/Icons/Scene_SendEvent.png" width=64 height=64 border=1>
</p>

<p>
Define and send an event
</p>
<em>Inputs</em>
<ul>
<li>
EventName: Unique event name to send
</li>
<li>
DataTree: DataTree to send
</li>
</ul>
<em>Outputs</em>
<ul>
</ul>
<h2>Scene_HandleEvent</h2>

<p>
<img src="Data/Textures/Icons/Scene_HandleEvent.png" width=64 height=64 border=1>
</p>

<p>
Receive an Event
</p>
<em>Inputs</em>
<ul>
<li>
EventName: Unique event name to send
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
DataTree: DataTree to send
</li>
</ul>
<h2>Scene_SetGlobalVar</h2>

<p>
<img src="Data/Textures/Icons/Scene_SetGlobalVar.png" width=64 height=64 border=1>
</p>

<p>
Sets a global variant by name (key)
</p>
<em>Inputs</em>
<ul>
<li>
Key: Key of variant to set.
</li>
<li>
Variant: Variant to set
</li>
<li>
Reset: Reset to null value
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Variant: Set variant
</li>
</ul>
<h2>Scene_GetGlobalVar</h2>

<p>
<img src="Data/Textures/Icons/Scene_GetGlobalVar.png" width=64 height=64 border=1>
</p>

<p>
Gets a global variant by name (key)
</p>
<em>Inputs</em>
<ul>
<li>
VarName: Key of variant to get.
</li>
<li>
DefaultValue: Default value if get fails.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Variant: Returned variant
</li>
</ul>
<h2>Scene_TriMeshVisualizeScalarField</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Visualize scalar field on a TriMesh
</p>
<em>Inputs</em>
<ul>
<li>
TriMesh: TriMesh input
</li>
<li>
ScalarField: Scalar field on the input TriMesh
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Node: Node ID of displayed TriMesh
</li>
<li>
Model: Pointer to model
</li>
</ul>
<h2>Scene_LoadScene</h2>

<p>
<img src="Data/Textures/Icons/Scene_LoadScene.png" width=64 height=64 border=1>
</p>

<p>
Loads a Scene resource file from XML or JSON
</p>
<em>Inputs</em>
<ul>
<li>
ScenePath: Resource Path to scene file
</li>
<li>
Additive: If true, loads scene additively
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
SceneReference: Pointer to loaded scene
</li>
</ul>
<h2>Scene_SaveScene</h2>

<p>
<img src="Data/Textures/Icons/Scene_SaveScene.png" width=64 height=64 border=1>
</p>

<p>
Saves current Scene resource file from XML or JSON
</p>
<em>Inputs</em>
<ul>
<li>
ScenePath: Resource Path to scene file
</li>
<li>
UseJson: If true, will write to JSON format. Otherwise XML.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Success: Returns true if file was written
</li>
</ul>
<h2>Scene_AppendRenderPath</h2>

<p>
<img src="Data/Textures/Icons/Scene_AppendRenderPath.png" width=64 height=64 border=1>
</p>

<p>
Appends a render path item to a viewport.
</p>
<em>Inputs</em>
<ul>
<li>
RenderPath: Path to render path definition
</li>
<li>
ViewportID: Viewport ID to add render path to.
</li>
<li>
Parameters: Set additional render path parameters
</li>
<li>
Values: Addtional render path values
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Tags: Append Render path tags
</li>
</ul>
<h2>Mesh_DecimateMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_DecimateMesh.png" width=64 height=64 border=1>
</p>

<p>
Perform decimation on triangle mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh before decimation
</li>
<li>
Target Face Count: Target number of faces
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after decimation
</li>
</ul>
<h2>Maths_ConstructTransform</h2>

<p>
<img src="Data/Textures/Icons/Maths_ConstructTransform.png" width=64 height=64 border=1>
</p>

<p>
Construct transform from position, scale, and rotation
</p>
<em>Inputs</em>
<ul>
<li>
Position: Vector3 position
</li>
<li>
Scale: Vector3 or float scale
</li>
<li>
Rotation: Quaternion for rotation
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Transform: Matrix3x4 representing a Transform
</li>
</ul>
<h2>Scene_DeconstructTransform</h2>

<p>
<img src="Data/Textures/Icons/Scene_DeconstructTransform.png" width=64 height=64 border=1>
</p>

<p>
Deconstruct a transform into position, rotation, and scale
</p>
<em>Inputs</em>
<ul>
<li>
Transform: Transform to deconstruct
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Position: Position
</li>
<li>
Scale: Scale
</li>
<li>
Rotation: Rotation
</li>
</ul>
<h2>Vector_ConstructVector</h2>

<p>
<img src="Data/Textures/Icons/Vector_ConstructVector.png" width=64 height=64 border=1>
</p>

<p>
Construct a vector from xyz-coordinates
</p>
<em>Inputs</em>
<ul>
<li>
X: X coordinate
</li>
<li>
Y: Y coordinate
</li>
<li>
Z: Z coordinate
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Vector3: Vector3 out
</li>
</ul>
<h2>Input_Inspect</h2>

<p>
<img src="Data/Textures/Icons/Input_Inspect.png" width=64 height=64 border=1>
</p>

<p>
Convert tree to string for inspection
</p>
<em>Inputs</em>
<ul>
<li>
TreeIn: Input Tree
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
TreeOut: Output Tree
</li>
</ul>
<h2>Mesh_SmoothMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_SmoothMesh.png" width=64 height=64 border=1>
</p>

<p>
Perform smoothing on triangle mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh before smoothing
</li>
<li>
Iterations: Number of smoothing iterations
</li>
<li>
Target Factor: Move towards smoothed target by factor
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after smoothing
</li>
</ul>
<h2>Input_ScreenSlider</h2>

<p>
<img src="Data/Textures/Icons/Input_ScreenSlider.png" width=64 height=64 border=1>
</p>

<p>
Adds a slider to the user interface
</p>
<em>Inputs</em>
<ul>
<li>
Position: Optional position. If left blank, the element is automatically positioned.
</li>
<li>
Range: Range of slider
</li>
<li>
Label: Label
</li>
<li>
Priority: Priority
</li>
<li>
Parent: Optional Parent element
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Screen Slider Out: Ptrs of Slider on Screen
</li>
</ul>
<h2>Tree_Flatten</h2>

<p>
<img src="Data/Textures/Icons/Tree_Flatten.png" width=64 height=64 border=1>
</p>

<p>
Perform flattening on a tree
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree to flatten
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IoDataTree: Flattened IoDataTree
</li>
</ul>
<h2>Tree_Graft</h2>

<p>
<img src="Data/Textures/Icons/Tree_Graft.png" width=64 height=64 border=1>
</p>

<p>
Perform grafting on a tree
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree to graft
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IoDataTree: Grafted IoDataTree
</li>
</ul>
<h2>Tree_Reverse</h2>

<p>
<img src="Data/Textures/Icons/Tree_Reverse.png" width=64 height=64 border=1>
</p>

<p>
Perform reversal on a tree
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree to reverse
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IoDataTree: Reversed IoDataTree
</li>
</ul>
<h2>Tree_Simplify</h2>

<p>
<img src="Data/Textures/Icons/Tree_Simplify.png" width=64 height=64 border=1>
</p>

<p>
Perform simplification on a tree
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree to simplify
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IoDataTree: Simplified IoDataTree
</li>
</ul>
<h2>Tree_GetItem</h2>

<p>
<img src="Data/Textures/Icons/Tree_GetItem.png" width=64 height=64 border=1>
</p>

<p>
Get Tree Item by path and index
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree storing lookup item
</li>
<li>
Branch (int): Path in branch in tree
</li>
<li>
Optional Index: Index of item in list
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Item: Item from tree
</li>
</ul>
<h2>Tree_FlipMatrix</h2>

<p>
<img src="Data/Textures/Icons/Tree_FlipMatrix.png" width=64 height=64 border=1>
</p>

<p>
Perform flattening on a tree
</p>
<em>Inputs</em>
<ul>
<li>
IoDataTree: IoDataTree to flatten
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IoDataTree: Flattened IoDataTree
</li>
</ul>
<h2>Sets_ListLength</h2>

<p>
<img src="Data/Textures/Icons/Sets_ListLength.png" width=64 height=64 border=1>
</p>

<p>
Compute list lengths for tree nodes
</p>
<em>Inputs</em>
<ul>
<li>
DataTree: IoDataTree storing lists at nodes
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
LengthTree: IoDataTree storing lengths at nodes
</li>
</ul>
<h2>Sets_VariantMap</h2>

<p>
<img src="Data/Textures/Icons/Sets_VariantMap.png" width=64 height=64 border=1>
</p>

<p>
Construct a variant map from keys and values
</p>
<em>Inputs</em>
<ul>
<li>
Key: Key
</li>
<li>
Value: Value
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Map: Variant Map
</li>
</ul>
<h2>Mesh_ReadTriangleMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_ReadTriangleMesh.png" width=64 height=64 border=1>
</p>

<p>
Read triangle mesh from file
</p>
<em>Inputs</em>
<ul>
<li>
Mesh file: Path to file storing the mesh (obj, off, ply, dxf)
</li>
<li>
Force Y Up: Force y-axis to vertical/up
</li>
<li>
Transform: Apply transform to imported geometry
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh out: Mesh structure out
</li>
<li>
Polylines out: Polylines out
</li>
<li>
Points out: Points out
</li>
</ul>
<h2>Mesh_DeconstructTriangleMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_DeconstructTriangleMesh.png" width=64 height=64 border=1>
</p>

<p>
Deconstructs a triangle mesh into vertices, faces, and normals
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Path to Model
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Vertices: Vertices Out
</li>
<li>
Faces: Faces Out
</li>
<li>
Normals: Normals Out
</li>
<li>
FaceCounts: Faces counts
</li>
</ul>
<h2>Mesh_ConstructTriangleMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_ConstructTriangleMesh.png" width=64 height=64 border=1>
</p>

<p>
Construct a mesh from vertex and face lists
</p>
<em>Inputs</em>
<ul>
<li>
Vertices: List of coordinates of vertices
</li>
<li>
Faces: List of face indices
</li>
<li>
Normals: List of vertex normals. If ommitted, they will be computed.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Constructed mesh
</li>
</ul>
<h2>Mesh_ClosestPoint</h2>

<p>
<img src="Data/Textures/Icons/Mesh_ClosestPoint.png" width=64 height=64 border=1>
</p>

<p>
Find point on Mesh closest to query point
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to search
</li>
<li>
Query Point: Point to search from
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Point: Point on mesh closest to query point
</li>
<li>
Index: Index of closest face
</li>
<li>
Distance: Distance from query point to mesh
</li>
</ul>
<h2>Mesh_HexayurtMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_HexayurtMesh.png" width=64 height=64 border=1>
</p>

<p>
Construct a hexayurt mesh from scale
</p>
<em>Inputs</em>
<ul>
<li>
Width: Width to thicken by
</li>
<li>
Transformation: Transformation to apply to hexayurt
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Hexayurt Mesh
</li>
</ul>
<h2>Mesh_CubeMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_CubeMesh.png" width=64 height=64 border=1>
</p>

<p>
Construct a cube mesh from scale
</p>
<em>Inputs</em>
<ul>
<li>
Side: Side length
</li>
<li>
Transformation: Transformation to apply to cube
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Cube Mesh
</li>
</ul>
<h2>Mesh_Icosahedron</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Icosahedron.png" width=64 height=64 border=1>
</p>

<p>
Construct an icosahedron mesh from scale
</p>
<em>Inputs</em>
<ul>
<li>
Transformation: Transformation to apply to cube
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Icosahedron Mesh
</li>
</ul>
<h2>Mesh_Sphere</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Sphere.png" width=64 height=64 border=1>
</p>

<p>
Construct a sphere mesh from scale
</p>
<em>Inputs</em>
<ul>
<li>
Transformation: Transformation to apply to cube
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Icosahedron Mesh
</li>
</ul>
<h2>Mesh_SaveMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_SaveMesh.png" width=64 height=64 border=1>
</p>

<p>
Saves a mesh in a variety of formats
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to save
</li>
<li>
Path: Path
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Result: Result
</li>
</ul>
<h2>Mesh_CleanMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_CleanMesh.png" width=64 height=64 border=1>
</p>

<p>
Cull unused vertices from trimesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh with unused vertices
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after removing unused vertices
</li>
<li>
NumRemoved: Number of vertices removed
</li>
</ul>
<h2>Mesh_BoundingBox</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Construct TriMesh bounding box for another TriMesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
BoxMesh: Meshed bounding box of input mesh
</li>
</ul>
<h2>Mesh_HausdorffDistance</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Compute Hausdorff distance between TriMeshes
</p>
<em>Inputs</em>
<ul>
<li>
Mesh1: First mesh
</li>
<li>
Mesh2: Second mesh
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
HausdorffDistance: Hausdorff distance between input meshes
</li>
</ul>
<h2>Mesh_HarmonicDeformation</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Given some displacement vectors, the harmonic deformation field is calculated
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to deform
</li>
<li>
Displacement vectors.: Displacement vectors. Must be parallel to index list.
</li>
<li>
Displacement indices: Index of mesh vertices to move. Must be parallel to vector list.
</li>
<li>
Harmonic exponent.: Exponent that controls the deformation field solve
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Harmonic Displacements: Harmonic displacemnt vectors
</li>
<li>
Mesh: Transormed Mesh
</li>
</ul>
<h2>Curve_Polyline</h2>

<p>
<img src="Data/Textures/Icons/Curve_Polyline.png" width=64 height=64 border=1>
</p>

<p>
Construct a polyline from a vertex list
</p>
<em>Inputs</em>
<ul>
<li>
Vertices: List of coordinates of vertices
</li>
<li>
Close: Close the curve
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Polyline: Constructed polyline
</li>
</ul>
<h2>Curve_OffsetPolyline</h2>

<p>
<img src="Data/Textures/Icons/Curve_OffsetPolyline.png" width=64 height=64 border=1>
</p>

<p>
Offsets a polyline by offsetting its vertices
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline to offset
</li>
<li>
Distance: Distance to offset by
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Offset Polyline: Offset polyline
</li>
</ul>
<h2>Curve_SmoothPolyline</h2>

<p>
<img src="Data/Textures/Icons/Curve_SmoothPolyline.png" width=64 height=64 border=1>
</p>

<p>
Smooth polyline via subdivision
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline to smooth
</li>
<li>
Iterations: Number of smoothing iterations to perform
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Smoothed Polyline: Smoothed and subdivided polyline
</li>
</ul>
<h2>Curve_LineSegment</h2>

<p>
<img src="Data/Textures/Icons/Curve_LineSegment.png" width=64 height=64 border=1>
</p>

<p>
Construct a line segment from start and end vertices
</p>
<em>Inputs</em>
<ul>
<li>
StartVertex: Start of segment
</li>
<li>
EndVertex: End of segment
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
LineSegment: Constructed line segment
</li>
</ul>
<h2>Curve_PolylineBlend</h2>

<p>
<img src="Data/Textures/Icons/Curve_PolylineBlend.png" width=64 height=64 border=1>
</p>

<p>
Lofts a collection of polylines into a mesh
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: First polyline
</li>
<li>
Polyline: Second polyline
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Lofted mesh
</li>
</ul>
<h2>Curve_PolylineDivide</h2>

<p>
<img src="Data/Textures/Icons/Curve_PolylineDivide.png" width=64 height=64 border=1>
</p>

<p>
Divide polyline into equal parts
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline to divide
</li>
<li>
NumParts: Number of parts
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
DividedPolyline: Polyline divided into parts
</li>
</ul>
<h2>Curve_PolylineLoft</h2>

<p>
<img src="Data/Textures/Icons/Curve_PolylineLoft.png" width=64 height=64 border=1>
</p>

<p>
Perform loft operation on a list of polylines
</p>
<em>Inputs</em>
<ul>
<li>
PolylineList: List of polylines to loft
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Lofted mesh
</li>
</ul>
<h2>Curve_PolylineEvaluate</h2>

<p>
<img src="Data/Textures/Icons/Curve_EvaluatePolyline.png" width=64 height=64 border=1>
</p>

<p>
Evaluate point on polyline from parameter
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline
</li>
<li>
Parameter: Parameter to evaluate
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Point: Point on polyline corresponding to parameter
</li>
<li>
Transform: Transform on polyline corresponding to parameter
</li>
</ul>
<h2>Curve_Polygon</h2>

<p>
<img src="Data/Textures/Icons/Curve_Polygon.png" width=64 height=64 border=1>
</p>

<p>
Construct a polygon with n sides
</p>
<em>Inputs</em>
<ul>
<li>
Number of sides: Number of sides for the polygon
</li>
<li>
Transformation: Transformation to apply to polygon
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Polygon: Constructed polygon
</li>
<li>
Vertices: Constructed vertices
</li>
</ul>
<h2>Curve_SketchPlane</h2>

<p>
<img src="Data/Textures/Icons/Curve_SketchPlane.png" width=64 height=64 border=1>
</p>

<p>
Create a sketch and position it in 3D.
</p>
<em>Inputs</em>
<ul>
<li>
Curves: Storage and/or optional input curves
</li>
<li>
Reset: Resets the sketch area
</li>
<li>
Mode: Freeform or Line Mode
</li>
<li>
Transform: Transform to map curve points
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Curves: Resulting Curves
</li>
<li>
Texture: Sketch Texture
</li>
</ul>
<h2>Curve_Rebuild</h2>

<p>
<img src="Data/Textures/Icons/Curve_RebuildPolyline.png" width=64 height=64 border=1>
</p>

<p>
Refine polyline based on list of parameters
</p>
<em>Inputs</em>
<ul>
<li>
Curve: Rebuilds the curve with the given number of segments
</li>
<li>
NumPoints: Number of target points
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Curve: The rebuilt curve.
</li>
</ul>
<h2>Curve_Length</h2>

<p>
<img src="Data/Textures/Icons/Curve_Length.png" width=64 height=64 border=1>
</p>

<p>
Calculates the length of a curve.
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Length: Curve Length
</li>
</ul>
<h2>Curve_ReadBagOfEdges</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
Read bag of edges from file
</p>
<em>Inputs</em>
<ul>
<li>
Edge file: Path to file storing the edges (obj, off, ply, dxf)
</li>
<li>
Force Y Up: Force y-axis to vertical/up
</li>
<li>
Transform: Apply transform to imported geometry
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Polylines out: Polylines out
</li>
</ul>
<h2>Mesh_SubdivideMesh</h2>

<p>
<img src="Data/Textures/Icons/Mesh_SubdivideMesh.png" width=64 height=64 border=1>
</p>

<p>
Perform subdivision on triangle mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh before subdivision
</li>
<li>
Steps: Number of subdivision steps
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after subdivision
</li>
</ul>
<h2>Input_SliderListener</h2>

<p>
<img src="Data/Textures/Icons/Input_SliderListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for slider input
</p>
<em>Inputs</em>
<ul>
<li>
Sliders: Pointers to sliders
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Slider Values: Values of Sliders out
</li>
</ul>
<h2>Vector_DeconstructVector</h2>

<p>
<img src="Data/Textures/Icons/Vector_DeconstructVector.png" width=64 height=64 border=1>
</p>

<p>
Deconstruct a vector into its components
</p>
<em>Inputs</em>
<ul>
<li>
Vector: Vector to deconstruct
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
X-Coordinate: X-Coordinate of vector
</li>
<li>
Y-Coordinate: Y-Coordinate of vector
</li>
<li>
Z-Coordinate: Z-Coordinate of vector
</li>
</ul>
<h2>Maths_EvalFunction</h2>

<p>
<img src="Data/Textures/Icons/Maths_EvalFunction.png" width=64 height=64 border=1>
</p>

<p>
Evaluates a basic math function.
</p>
<em>Inputs</em>
<ul>
<li>
First Arg: First input
</li>
<li>
Second Arg: Second input
</li>
<li>
Third Arg: Third input
</li>
<li>
Function: Function definition in Script
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Result: Evaluated result
</li>
</ul>
<h2>Vector_ClosestPoint</h2>

<p>
<img src="Data/Textures/Icons/Vector_ClosestPoint.png" width=64 height=64 border=1>
</p>

<p>
Which point in list is closest
</p>
<em>Inputs</em>
<ul>
<li>
Point: Query point
</li>
<li>
Point List: List of points
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Closest Point: Closest point in list to P
</li>
<li>
Index: Index into L of closest point
</li>
<li>
Distance: Distance to closest point
</li>
</ul>
<h2>Vector_Distance</h2>

<p>
<img src="Data/Textures/Icons/Vector_Distance.png" width=64 height=64 border=1>
</p>

<p>
Compute distance between vectors
</p>
<em>Inputs</em>
<ul>
<li>
Vector: First vector
</li>
<li>
Vector: Second vector
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Distance: Distance between vectors
</li>
</ul>
<h2>Vector_ColorRGBA</h2>

<p>
<img src="Data/Textures/Icons/Vector_ColorRGBA.png" width=64 height=64 border=1>
</p>

<p>
Construct a color from RGBA values
</p>
<em>Inputs</em>
<ul>
<li>
R: Red
</li>
<li>
G: Green
</li>
<li>
B: Blue
</li>
<li>
A: Alpha
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Color: Color
</li>
</ul>
<h2>Vector_ColorPalette</h2>

<p>
<img src="Data/Textures/Icons/Vector_ColorPalette.png" width=64 height=64 border=1>
</p>

<p>
Which point in list is closest
</p>
<em>Inputs</em>
<ul>
<li>
StartColor: Start Color
</li>
<li>
Length: Number of colors to generate
</li>
<li>
Variance: Variance of colors
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ResultingColors: Resulting Colors
</li>
</ul>
<h2>Vector_BestFitPlane</h2>

<p>
<img src="Data/Textures/Icons/Vector_BestFitPlane.png" width=64 height=64 border=1>
</p>

<p>
Compute the least-squares plane of best fit
</p>
<em>Inputs</em>
<ul>
<li>
Geometry: Geometry determining the point cloud
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Point: Reference point on best-fit plane
</li>
<li>
Normal: Normal to best-fit plane
</li>
</ul>
<h2>Scene_UpdateListener</h2>

<p>
<img src="Data/Textures/Icons/Scene_UpdateListener.png" width=64 height=64 border=1>
</p>

<p>
Listens for scene updates
</p>
<em>Inputs</em>
<ul>
<li>
Mute: Mute the listener
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ElapsedTime: Elapsed Time since last start
</li>
<li>
DeltaTime: Frame update time
</li>
</ul>
<h2>Mesh_Offset</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Offset.png" width=64 height=64 border=1>
</p>

<p>
Perform offset operation on a triangle mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to offset
</li>
<li>
Width: Width to offset by
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after offsetting
</li>
</ul>
<h2>Mesh_Window</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Window.png" width=64 height=64 border=1>
</p>

<p>
Creates a set of windows from a mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to ...
</li>
<li>
Inset Factor: Factor controlling amount of inset
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Windowed mesh
</li>
</ul>
<h2>Mesh_Frame</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Frame.png" width=64 height=64 border=1>
</p>

<p>
Creates an inset frame mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to ...
</li>
<li>
Inset Factor: Factor controlling amount of inset
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Framed mesh
</li>
</ul>
<h2>Mesh_Thicken</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Thicken.png" width=64 height=64 border=1>
</p>

<p>
Perform thickening operation on a triangle mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to thicken
</li>
<li>
Width: Width to thicken by
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after thickening
</li>
</ul>
<h2>Mesh_LoopSubdivide</h2>

<p>
<img src="Data/Textures/Icons/Mesh_LoopSubdivide.png" width=64 height=64 border=1>
</p>

<p>
Perform loop subdivision on triangle mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh before subdivision
</li>
<li>
Iterations: Number of iterations to perform
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh after subdivision
</li>
</ul>
<h2>Mesh_ExtrudePolyline</h2>

<p>
<img src="Data/Textures/Icons/Mesh_ExtrudePolyline.png" width=64 height=64 border=1>
</p>

<p>
Extrudes a polyline along a vector
</p>
<em>Inputs</em>
<ul>
<li>
Polyline: Polyline to extrude
</li>
<li>
Extrude Direction: Vector along which to extrude
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Framed mesh
</li>
</ul>
<h2>Mesh_FillPolygon</h2>

<p>
<img src="Data/Textures/Icons/Mesh_FillPolygon.png" width=64 height=64 border=1>
</p>

<p>
Triangulates a polygon
</p>
<em>Inputs</em>
<ul>
<li>
Polygon: Tries to mesh a polygon
</li>
<li>
Holes: Holes of the polygon
</li>
<li>
Transform: Optional transform for triangulation
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Triangulated polygon
</li>
</ul>
<h2>Mesh_FacePolylines</h2>

<p>
<img src="Data/Textures/Icons/Mesh_FacePolylines.png" width=64 height=64 border=1>
</p>

<p>
Returns the face polylines from a mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Polylines: Polylines
</li>
</ul>
<h2>Mesh_Boundary</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Boundary.png" width=64 height=64 border=1>
</p>

<p>
Compute boundary of a mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh with boundary
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Boundary: Boundary of mesh as polyline
</li>
</ul>
<h2>Mesh_MeshPlaneIntersection</h2>

<p>
<img src="Data/Textures/Icons/Mesh_MeshPlaneIntersection.png" width=64 height=64 border=1>
</p>

<p>
Intersect triangle mesh with plane
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to intersect with plane
</li>
<li>
Point: Point on plane
</li>
<li>
Normal: Normal to plane
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh1: Mesh on normal side of plane
</li>
<li>
Mesh2: Mesh on non-normal side of plane
</li>
</ul>
<h2>Mesh_JoinMeshes</h2>

<p>
<img src="Data/Textures/Icons/Mesh_JoinMeshes.png" width=64 height=64 border=1>
</p>

<p>
Join meshes in a list into a single mesh
</p>
<em>Inputs</em>
<ul>
<li>
MeshList: List of meshes
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
JoinMesh: Joined mesh
</li>
</ul>
<h2>Mesh_TriMeshVolume</h2>

<p>
<img src="Data/Textures/Icons/Mesh_TriMeshVolume.png" width=64 height=64 border=1>
</p>

<p>
Compute volume of TriMesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh input to volume computation
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Volume: Volume of mesh
</li>
</ul>
<h2>Mesh_Tetrahedralize</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Tetrahedralize.png" width=64 height=64 border=1>
</p>

<p>
Create a tetrahedralization of a mesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh to tetrahedralize
</li>
<li>
Volume: Optional volume condition
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
MeshOut: Tetrahedralized mesh out
</li>
</ul>
<h2>Mesh_UnifyNormals</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Unify TriMesh normals to consistent orientation
</p>
<em>Inputs</em>
<ul>
<li>
MeshIn: Mesh in
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
MeshOut: Mesh with unified normals
</li>
</ul>
<h2>Mesh_AverageEdgeLength</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Compute average edge length for TriMesh
</p>
<em>Inputs</em>
<ul>
<li>
MeshIn: Mesh to compute average edge length on
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Length: Average edge length
</li>
</ul>
<h2>Mesh_CollapseShortEdges</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Collapse edges shorter than (1 - tol) * avg
</p>
<em>Inputs</em>
<ul>
<li>
TriMesh: TriMesh before edge collapses
</li>
<li>
Tol: Collapse edges shorter than (1 - tol) * avg
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
TriMesh: TriMesh after edge collapses
</li>
</ul>
<h2>Mesh_MeanCurvatureFlow</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Mean Curvature Flow on TriMesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: Mesh input
</li>
<li>
NumSteps: Number of steps to flow
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh output
</li>
</ul>
<h2>Mesh_PerVertexEval</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Evaluates function on vertices of TriMesh
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: TriMesh input
</li>
<li>
Function: Function definition in Script
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
ResultList: List of results evaluated on each vertex
</li>
</ul>
<h2>Spatial_ReadOSM</h2>

<p>
<img src="Data/Textures/Icons/Spatial_ReadOSM.png" width=64 height=64 border=1>
</p>

<p>
Reads an OSM file
</p>
<em>Inputs</em>
<ul>
<li>
OSMFile: Path to OSM File (XML)
</li>
<li>
Scale: Scale
</li>
<li>
Options: OSM Options
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Ways: Ways
</li>
<li>
Buildings: Buildings
</li>
<li>
BuildingHeight: Building Height
</li>
</ul>
<h2>Spatial_Terrain</h2>

<p>
<img src="Data/Textures/Icons/Spatial_Terrain.png" width=64 height=64 border=1>
</p>

<p>
Terrain Object
</p>
<em>Inputs</em>
<ul>
<li>
ImageFile: Image File
</li>
<li>
Material: Material Path
</li>
<li>
Transform: Transform
</li>
<li>
Spacing: Grid Spacing
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NodeID: Node ID
</li>
<li>
Terrain: Terrain
</li>
</ul>
<h2>Spatial_Sun</h2>

<p>
<img src="Data/Textures/Icons/Spatial_Sun.png" width=64 height=64 border=1>
</p>

<p>
Create a directional Sun light
</p>
<em>Inputs</em>
<ul>
<li>
Latitude: Latitude
</li>
<li>
Longitude: Longitude
</li>
<li>
Month: Month
</li>
<li>
Day: Day
</li>
<li>
Hour: Hour
</li>
<li>
Color: Color
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
NodeID: Node ID
</li>
<li>
Sun: SunPtr
</li>
</ul>
<h2>Mesh_SplitLongEdges</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Split edges longer than (1 + tol) * avg
</p>
<em>Inputs</em>
<ul>
<li>
TriMesh: TriMesh before edge splits
</li>
<li>
Tol: Split edges longer than (1 + tol) * avg
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
TriMesh: TriMesh after edge splits
</li>
</ul>
<h2>Mesh_ComputeAdjacencyData</h2>

<p>
<img src="Data/Textures/Icons/Mesh_ComputeAdjacencyData.png" width=64 height=64 border=1>
</p>

<p>
Computes Mesh Topology Data (manifold trimeshes only!)
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: TriMesh
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Mesh: Mesh with topology data computed
</li>
</ul>
<h2>Mesh_FaceTopology</h2>

<p>
<img src="Data/Textures/Icons/Mesh_FaceTopology.png" width=64 height=64 border=1>
</p>

<p>
Computes Mesh Topology Data for face
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: TriMeshWithAdjacencyData
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
IncidentVertIDs: Indices of vertices incident to F
</li>
<li>
IncidentVertices: Vertices incident to F
</li>
<li>
AdjFaces: Indices of faces adjacent to F
</li>
</ul>
<h2>Mesh_VertexTopology</h2>

<p>
<img src="Data/Textures/Icons/Mesh_VertexTopology.png" width=64 height=64 border=1>
</p>

<p>
Computes Mesh Topology Data for vertices
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: TriMeshWithAdjacencyData
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
VertexStarIDs: Indices of vertices adjacent to V
</li>
<li>
VertexStar: Vertices adjacent to V
</li>
<li>
AdjFaces: Indices of faces incident to V
</li>
</ul>
<h2>Mesh_BoundaryVertices</h2>

<p>
<img src="Data/Textures/Icons/Mesh_BoundaryVertices.png" width=64 height=64 border=1>
</p>

<p>
Computes Mesh Topology Data for a given vertex
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: TriMesh
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
BoundaryVertexIDs: Indices of vertices on mesh boundary
</li>
<li>
BoundaryVertices: Vertices on boundary
</li>
<li>
InteriorVertexIDs: Indices of interior vertices of mesh
</li>
<li>
InteriorVertices: Vertices in mesh interior
</li>
</ul>
<h2>Mesh_DeconstructFace</h2>

<p>
<img src="Data/Textures/Icons/Mesh_DeconstructFace.png" width=64 height=64 border=1>
</p>

<p>
Returns normal, centroid and vertices of face
</p>
<em>Inputs</em>
<ul>
<li>
Mesh: TriMesh
</li>
<li>
FaceID: ID of face of interest
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
FaceVertexIDs: Indices of vertices on mesh face
</li>
<li>
FaceVertices: Vertices on face
</li>
<li>
FaceNormal: Normal to face
</li>
<li>
FaceCentroid: Centroid of face
</li>
</ul>
<h2>Mesh_Torus</h2>

<p>
<img src="Data/Textures/Icons/Mesh_Torus.png" width=64 height=64 border=1>
</p>

<p>
Construct a torus mesh from radii
</p>
<em>Inputs</em>
<ul>
<li>
OuterRadius: Outer radius
</li>
<li>
InnerRadius: Inner radius
</li>
<li>
FirstPower: FirstPower
</li>
<li>
SecondPower: SecondPower
</li>
<li>
MeshResolution: Integer (>3) describing mesh resolution
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
QuadMesh: Torus QuadMesh
</li>
<li>
TriMesh: Torus TriMesh
</li>
</ul>
<h2>Mesh_FlipNormals</h2>

<p>
<img src="Data/" width=64 height=64 border=1>
</p>

<p>
Unify TriMesh normals to consistent orientation
</p>
<em>Inputs</em>
<ul>
<li>
MeshIn: Mesh in
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
MeshOut: Mesh with flipped normals
</li>
</ul>
<h2>ShapeOp_Solve</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
Constraint List: Constraint List
</li>
<li>
WeldDist: Weld points within distance
</li>
<li>
Gravity: Gravity
</li>
<li>
Mass: Mass (assigned to all points; 1.0f default)
</li>
<li>
Damping: Damping (default 1.0f)
</li>
<li>
Timestep: Timestep (default 1.0f)
</li>
<li>
Iterations: Iterations for solver (default 10)
</li>
<li>
MeshList: List of tracked meshes
</li>
<li>
ResetPts: Reset points
</li>
<li>
Restart: Restart
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Points: Point list output
</li>
<li>
MeshList: Mesh list output
</li>
</ul>
<h2>ShapeOp_EdgeStrain</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
Start: Start point of edge
</li>
<li>
End: End point of edge
</li>
<li>
Weight: Weight of edge constraint
</li>
<li>
rangeMin: rangeMin for ShapeOp EdgeConstraint
</li>
<li>
rangeMax: rangeMax for ShapeOp EdgeConstraint
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
EdgeStrain: EdgeStrain ShapeOp constraint
</li>
</ul>
<h2>ShapeOp_TriangleStrain</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
vertexA: Triangle vertex A
</li>
<li>
vertexB: Triangle vertex B
</li>
<li>
vertexC: Triangle vertex C
</li>
<li>
Weight: Weight of edge constraint
</li>
<li>
rangeMin: rangeMin for ShapeOp EdgeConstraint
</li>
<li>
rangeMax: rangeMax for ShapeOp EdgeConstraint
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
TriangleStrain: TriangleStrain ShapeOp constraint
</li>
</ul>
<h2>ShapeOp_Closeness</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
Position: Target position
</li>
<li>
Weight: Weight of edge constraint
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Closeness: Closeness ShapeOp constraint
</li>
</ul>
<h2>ShapeOp_GeometryStrain</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
Geometry: Mesh or polyline geometry
</li>
<li>
Weight: Weight of strain
</li>
<li>
Max: Max of strain
</li>
<li>
Min: Min strain.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
EdgeStrain: Edge Strain
</li>
</ul>
<h2>ShapeOp_MeshTriangleStrain</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
Geometry: Mesh or polyline geometry
</li>
<li>
Weight: Weight of strain
</li>
<li>
Max: Max of strain
</li>
<li>
Min: Min strain.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
EdgeStrain: Edge Strain
</li>
</ul>
<h2>ShapeOp_GenericConstraint</h2>

<p>
<img src="Data/Textures/Icons/DefaultIcon.png" width=64 height=64 border=1>
</p>

<p>
...
</p>
<em>Inputs</em>
<ul>
<li>
Type: Constraint type.
</li>
<li>
Vertices: Vertices that define the constraint
</li>
<li>
Weight: Weight of strain
</li>
<li>
Max: Max of strain
</li>
<li>
Min: Min strain.
</li>
</ul>
<em>Outputs</em>
<ul>
<li>
Constraint: Generic Constraint
</li>
</ul>
